
   
/* WORD LADDER Main.java
 * EE422C Project 3 submission by
 * Replace <...> with your actual data.
 * Roberto Reyes
 * rcr2662
 * 17360
 * <Student2 Name>
 * <Student2 EID>
 * <Student2 5-digit Unique No.>
 * Slip days used: <0>
 * Git URL:
 * Spring 2022
 */


package assignment3;
import java.util.*;
import java.io.*;

public class Main {
	
	// static variables and constants only here.
	private static String START = "";
	public static String END = ""; 
	private static ArrayList<String> ladder_h = new ArrayList<String>();
	protected static Set<String> makeDick =  makeDictionary();
	public static void main(String[] args) throws Exception {
		
		
		Scanner kb;	// input Scanner for commands
		PrintStream ps;	// output file, for student testing and grading only
		// If arguments are specified, read/write from/to files instead of Std IO.
		if (args.length != 0) {
			kb = new Scanner(new File(args[0]));
			ps = new PrintStream(new File(args[1]));
			System.setOut(ps);			// redirect output to ps
		} else {
			kb = new Scanner(System.in);// default input from Stdin
			ps = System.out;			// default output to Stdout
		}
		initialize();
		
		// TODO methods to read in words, output ladder
		ArrayList<String> input = new ArrayList<String>();	//command input
		ArrayList<String> bfs_ladder = new ArrayList<String>();	//ladder generated by bfs
		ArrayList<String> dfs_ladder = new ArrayList<String>();	//ladder generated by dfs
		input = parse(kb);
		//While input is not /exit
		
		while(input != null){
			
			START = input.get(0);
			END = input.get(1);
		
			bfs_ladder = getWordLadderBFS(START, END);
			
			
			dfs_ladder = getWordLadderDFS(START, END);
			//printLadder(dfs_ladder);
			Erase_H();
			//print shortest ladder
			
			if (bfs_ladder.size() < dfs_ladder.size()){
				printLadder(bfs_ladder);
			}
			else {printLadder(dfs_ladder);}
			
			Erase_START();
			Erase_END();
			
			//get new input
			input = parse(kb);
		
		}
		
	}

	/**
	 * @param ladder ArrayList of Strings that contains start and end words.
	 * @return String containing indices of the characters that were different. 
	 */
	/*
	public static String getDiffIndex(String word1, String word2){
		int w_size = word1.length();	//word length
		char[] w1 = word1.toCharArray();	//word1 to char array
		char[] w2 = word2.toCharArray();	//word2 word to char array
		String diff_index ="";	//String difference index
		String index = "";
		//Compare strings
		for(int i = 0; i < w_size; i++){	
			index = Integer.toString(i);
			if(w1[i] != w2[i]){
				if(i == 0) diff_index = "0";
				diff_index += index;
			}
		}
		return diff_index;
	}
*/

protected static String Difference(String start,String end, int L)
{
String ret = "";
 
for(int x = 0; x < L; x++)
{if(start.charAt(x) != end.charAt(x)){ret+= (char) (x+'0');}}
 
return ret;
 
}
	
	public static void initialize() {
		// initialize your static variables or constants here.
		// We will call this method before running our JUNIT tests.  So call it 
		// only once at the start of main.
		Set<String> dictionary = new HashSet<String>();
		dictionary = makeDictionary();
		
	}
	
	/**
	 * @param keyboard Scanner connected to System.in
	 * @return ArrayList of Strings containing start word and end word. 
	 * If command is /quit, return empty ArrayList. 
	 */
	public static ArrayList<String> parse(Scanner keyboard) {
		// TO DO
		String cmd = keyboard.next();	//turn System.in into string
		String exit = "/exit";
		ArrayList<String> ladder = new ArrayList<String>();
		
		ladder.add(cmd.toUpperCase());
		cmd = keyboard.next();
		ladder.add(cmd.toUpperCase());
		
		if(ladder.contains(exit.toUpperCase()))
		{ladder = null;}
	
		return ladder;
	}
	
	public static ArrayList<String> getWordLadderDFS(String start, String end) {
		
		// Returned list should be ordered start to end.  Include start and end.
		// If ladder is empty, return list with just start and end.
		// TODO some code
		
		//creates the tree
		
		String Max_Diff = "";
		int const_len = start.length();
		for(int x = 0; x < start.length();x++)
		{Max_Diff+= String.valueOf(x);}
	
		ArrayList<String> ladder = new ArrayList<String>();
		
	if(end.equals(END))
	{Tree check_tree = new Tree(Max_Diff,END,"",1);
	if(check_tree.Get_All_Words(1).size() == 0)
	{ ladder.clear();
  	ladder.add(START);
  	ladder.add(END);
	return ladder;}
	
	}
	
		ladder.add(start);
		if(!ladder_h.contains(start))
			{ladder_h.add(start);}
		//String D_key = Difference(START,END,const_len); //OG TREE D_KEY		
		String Check_Diff = Difference(start,END,const_len); //Verifier
		String Dont_Check;
		if(start.equals(START))
		{ Dont_Check = Difference(start,start,const_len);}
		else { Dont_Check = Difference(start,end,const_len);}

		//Group End_Group = new Group(D_key,START,END,D_key); //END GROUP IN OG TREE
		
		
	  if(Check_Diff.length() <= 1)
	  { if(!ladder.contains(END)) {ladder.add(END);} 

	  return ladder;}
	  else if(ladder_h.size() == makeDick.size() ) {	
		  ladder.clear();
	  	ladder.add(START);
	  	ladder.add(END);
	  	return ladder;
	  }
	  
	
		

			//String YO_MOMMA = Difference(start,END,start.length()); //checks start input and END difference
			Tree OG_tree = new Tree(Max_Diff,start,END,1); //creates max tree of depth 1
			
			/*REDUCE TIME COMPLEXITY*/
			
				int bro_len = OG_tree.Get_All_Words(1).size();
	//System.out.println(Arrays.toString(OG_tree.Get_All_Words(1).toArray()));
			
				if(bro_len != 0)
				{
						
					//System.out.println(Arrays.toString(words_for_all.toArray()));
					int i = 0;	
					while(i < bro_len)
						{String new_start = OG_tree.Get_All_Words(1).get(i);
						String new_start_diff = Difference(new_start,start,const_len);
						if(ladder_h.contains(new_start) || Dont_Check.equals(new_start_diff)) {}
						else
							{
							ArrayList<String> new_ladder = getWordLadderDFS(new_start,start);
							
							if(new_ladder.contains(END) &&  !(new_ladder.get(0) == START && new_ladder.get(1) == END))
							{new_ladder.add(0,start);return new_ladder;}
						
							}
						
						  	i++;
					
							}
							//System.out.println("CHECKED");
						}
				
	 
	  	ladder.clear();
	  	ladder.add(START);
	  	ladder.add(END);
		return ladder; // replace this line later with real return
	   
	}
	


	private static void Erase_START()
	{START = "";}
	private static void Erase_END() {END = "";}
	private static void Erase_H() { ladder_h.clear();}
	
    public static ArrayList<String> getWordLadderBFS(String start, String end) {
		
		// TODO some code
    	ArrayList<String> ladder = new ArrayList<String>();
		ladder.add(start);
		int l_size = ladder.size();

    	String Max_Diff = "";
		int const_len = start.length();
		for(int x = 0; x < start.length();x++)
		{Max_Diff+= String.valueOf(x);}
		
		/* checks if end is impossible to reach*/

		ArrayList<String> visited = new ArrayList<String>();	//Keeps track of all visited words
		Tree gay_tree = new Tree(Max_Diff,end,"",1);
		int gay_tree_len = gay_tree.Get_All_Words(1).size();
		if(gay_tree_len == 0)
		{ 
		visited.add(start);
		visited.add(end);
		return visited;}
		
	
		
    	Tree tree = new Tree(Max_Diff, start, end, 1);	//Generates tree
	
		
		ArrayList<String> frontier = new ArrayList<String>();	//Queue for frontier groups
		ArrayList<String> new_frontier = new ArrayList<String>();	//Queue for other frontier groups in next level
	
		visited.add(start);
	
		frontier.addAll(tree.Get_All_Words(1));
		//System.out.println(tree.Get_All_Words(1));
		int Q_len = frontier.size();
		
		int y =0;

		outerloop:
		while(y == 0) {
		for(int x = 0; x < Q_len; x++)
			{
			int Diff = Difference(frontier.get(x),end,const_len).length();
			
			if(visited.contains(frontier.get(x)))  {continue;}
			else{visited.add(frontier.get(x));}
			
			if(Diff <=2) {
				 
				if(Diff == 2) {
					for(int q = 0; q <gay_tree_len; q++)
					{
						if(Difference(frontier.get(x),gay_tree.Get_All_Words(1).get(q),const_len).length() <=1)
						{  visited.add(gay_tree.Get_All_Words(1).get(q)); visited.add(end);  break outerloop;   }
					}
					
				}
				
				else{visited.add(end); break outerloop; }
				
				}
				
			Tree new_tree = new Tree(Max_Diff, frontier.get(x),end, 1);
			new_frontier.addAll(new_tree.Get_All_Words(1));
			
		}
		Collections.sort(new_frontier, new WordComparator());	//Call Word Comparator
		frontier.clear(); frontier.addAll(new_frontier); new_frontier.clear(); Q_len = frontier.size(); 
		}
		//Adds word closest to end word that is one char diff.
		ArrayList<String> furthest = new ArrayList<String>();
		out:
		for (int i = 0; i < visited.size(); i++){
			l_size = ladder.size();
			if(Difference(ladder.get(l_size), visited.get(i), const_len).length() == 1){
				furthest.add(visited.get(i));
			}
			for(int j = furthest.size(); j > 0; j--){
				if (!ladder.contains(furthest.get(j))){
					ladder.add(furthest.get(j));
					break;
				}
				if (furthest.get(j).equals(end)){
					break out;
				}
			}
			furthest.clear();
		}
		return ladder;
	}
	


    
	
	public static void printLadder(ArrayList<String> ladder) {
	// TODO
	// Other private static methods here
		int size = ladder.size();
		String start = ladder.get(0);
		String end = ladder.get(size - 1);

		if(size > 2){
			System.out.printf ("a %d-rung word ladder exists between %s and %s.\n", size-2, start, end); 
			//System.out.println (ladder.get(0).toLowerCase());	//Start word
			for (int i = 0; i < ladder.size(); i++) {	//Ladder words
            	System.out.println(ladder.get(i).toLowerCase());
        	}
			//System.out.println(ladder.get(1).toLowerCase());	//End word
		}else{
			System.out.printf("no word ladder can be found between %s and %s.\n", start, end);
		}
	}

	/* Do not modify makeDictionary */
	public static Set<String>  makeDictionary () {
		Set<String> words = new HashSet<String>();
		Scanner infile = null;
		try {
			infile = new Scanner (new File("five_letter_words.txt"));
		} catch (FileNotFoundException e) {
			System.out.println("Dictionary File not Found!");
			e.printStackTrace();
			System.exit(1);
		}
		while (infile.hasNext()) {
			words.add(infile.next().toUpperCase());
		}
		return words;
	}
	
	
}
	

