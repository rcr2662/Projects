
   
/* WORD LADDER Main.java
 * EE422C Project 3 submission by
 * Replace <...> with your actual data.
 * Roberto Reyes
 * rcr2662
 * 17360
 * <Student2 Name>
 * <Student2 EID>
 * <Student2 5-digit Unique No.>
 * Slip days used: <0>
 * Git URL:
 * Spring 2022
 */


package assignment3;
import java.util.*;
import java.io.*;
import assignment3.Tree;
import assignment3.Group;

public class Main {
	
	// static variables and constants only here.
private static String START = "";
private static String END = ""; 
private static ArrayList<String> ladder_h = new ArrayList<String>();
	public static void main(String[] args) throws Exception {
	
		
		Scanner kb;	// input Scanner for commands
		PrintStream ps;	// output file, for student testing and grading only
		// If arguments are specified, read/write from/to files instead of Std IO.
		if (args.length != 0) {
			kb = new Scanner(new File(args[0]));
			ps = new PrintStream(new File(args[1]));
			System.setOut(ps);			// redirect output to ps
		} else {
			kb = new Scanner(System.in);// default input from Stdin
			ps = System.out;			// default output to Stdout
		}
		initialize();
		
		// TODO methods to read in words, output ladder
		ArrayList<String> input = new ArrayList<String>();	//command input
		ArrayList<String> bfs_ladder = new ArrayList<String>();	//ladder generated by bfs
		//ArrayList<String> dfs_ladder = new ArrayList<String>();	//ladder generated by dfs
		input = parse(kb);

		//While input is not /exit
		while(input != null){
			bfs_ladder = getWordLadderBFS(input.get(0), input.get(1));
			Erase_H();
			//dfs_ladder = getWordLadderDFS(input.get(0), input.get(1));
			//Erase_H();
			//print shortest ladder
			//if (bfs_ladder.size() < dfs_ladder.size()){
				printLadder(bfs_ladder);
			//}else printLadder(dfs_ladder);

			Erase_START();
			Erase_END();
			
			//get new input
			input = parse(kb);
		}
		
	}

	/**
	 * @param ladder ArrayList of Strings that contains start and end words.
	 * @return String containing indices of the characters that were different. 
	 */
	public static String getDiffIndex(String word1, String word2){
		int w_size = word1.length();	//word length
		char[] w1 = word1.toCharArray();	//word1 to char array
		char[] w2 = word2.toCharArray();	//word2 word to char array
		String diff_index ="";	//String difference index
		String index = "";
		//Compare strings
		for(int i = 0; i < w_size; i++){	
			index = Integer.toString(i);
			if(w1[i] != w2[i]){
				if(i == 0) diff_index = "0";
				diff_index += index;
			}
		}
		return diff_index;
	}


protected static String Difference(String start,String end, int L)
{
String ret = "";
 
for(int x = 0; x < L; x++)
{if(start.charAt(x) != end.charAt(x)){ret+= (char) (x+'0');}}
 
return ret;
 
}
	
	public static void initialize() {
		// initialize your static variables or constants here.
		// We will call this method before running our JUNIT tests.  So call it 
		// only once at the start of main.
		Set<String> dictionary = new HashSet<String>();
		dictionary = makeDictionary();
		
	}
	
	/**
	 * @param keyboard Scanner connected to System.in
	 * @return ArrayList of Strings containing start word and end word. 
	 * If command is /quit, return empty ArrayList. 
	 */
	public static ArrayList<String> parse(Scanner keyboard) {
		// TO DO
		String cmd = keyboard.next();	//turn System.in into string
		String exit = "/exit";
		ArrayList<String> ladder = new ArrayList<String>();

		if(!(cmd.equals(exit))){	//if input is not /exit
		//Separate input into start and end words and store in ArrayList<String> ladder
		String[] split = cmd.split("\\s+");
		ladder.add(split[0].toUpperCase());
		ladder.add(split[1].toUpperCase());
		}
	
		return ladder;
	}
	
	public static ArrayList<String> getWordLadderDFS(String start, String end) {
		
		// Returned list should be ordered start to end.  Include start and end.
		// If ladder is empty, return list with just start and end.
		// TODO some code
		    //creates the tree
		String Max_Diff = "";
		String Fake_End = "";
		for(int x = 0; x < start.length();x++)
		{Max_Diff+= String.valueOf(x); Fake_End+="#";}
		//System.out.println("MAX_DIFF: " + Max_Diff);
		
		Tree tree = new Tree( Max_Diff, start, Fake_End,1);
		
		ArrayList<String> ladder = new ArrayList<String>();
	
		//ladder.add(START);
		//ladder.add(END);
		ladder.add(start);
		if(!ladder_h.contains(start))
			{ladder_h.add(start);}
		String D_key = Difference(START,END,START.length()); //OG TREE D_KEY
		Group End_Group = new Group(D_key,START,END,D_key); //END GROUP IN OG TREE
		
		String Check_Diff = Difference(start,END,start.length());
		
	  if(Check_Diff.length() <= 1)
	  { if(!ladder.contains(END)) {ladder.add(END);} 
	  //Erase_START();
	  //Erase_END();
	  //Erase_H();
	  return ladder;}
	  
	 
	  	
	   int child_len = tree.Get_Group("start").children.size();
	   for(int x = 0; x < child_len;x++)
	   { String child_ID = tree.Get_Group("start").children.get(x);
		   int words_len = tree.Get_Group(child_ID).words.size();
		   for(int y = 0; y < words_len;y++)
		   {
			   String new_start = tree.Get_Group(child_ID).words.get(y);
			   String Dont_Check = Difference(start,end,start.length());
			   String curr_Diff = Difference(new_start,start,start.length());
			  // System.out.println("start" + " " + start);
			   //System.out.println("new start" + " " + new_start);
			   //String OG_tree_ID_start = Difference(START,start,START.length());
			  //String OG_tree_ID_newstart = Difference(new_start,START,new_start.length());
			   
			  
			  if(ladder_h.contains(new_start) || Dont_Check.equals(curr_Diff) )
			  	{
				  //System.out.println(OG_tree_ID_start);
				  //System.out.println(OG_tree_ID_newstart);
				  //System.out.println(Dont_Check+ curr_Diff);
				 if(!ladder_h.contains(new_start))
					 {ladder_h.add(new_start);}
				 /* System.out.println("SKIP");*/  continue;}
			  String D_key_one = Difference(start,START,start.length());
			  String D_key_two = Difference(new_start,START,new_start.length());
			  //Group thingone = new Group(D_key_one,END,start,D_key_one,1);
			  //Group thingtwo = new Group(D_key_two,END,new_start,D_key_two,1);

			   if( !ladder_h.contains(new_start)   && ( End_Group.children.contains(D_key_two) || End_Group.parents.contains(D_key_two) || End_Group.get_ID().contains(D_key_two) ))
			  	{   //System.out.println("YO"); //ladder.add(new_start); 
			  	
			   
				 ArrayList<String> new_ladder = getWordLadderDFS(new_start,start);
				if(new_ladder.contains(END) &&  !(new_ladder.get(0) == START &&new_ladder.get(1) == END))
				{new_ladder.add(0,start);return new_ladder;}
			  	
			  	}
			   
			   
			   
			   else if( !ladder_h.contains(new_start) &&!Dont_Check.equals(curr_Diff))
			  {
				   //System.out.println("HI");
				  //ladder.add(new_start);
					 ArrayList<String> new_ladder = getWordLadderDFS(new_start,start);
						if(new_ladder.contains(END) && !(new_ladder.get(0) == START && new_ladder.get(1) == END))
						{new_ladder.add(0,start);return new_ladder;}
					
			  
			  }
			  
			  
		   }
	   }  
	 
	        
	  /*
if(ladder.size() == 1 && ladder_h.size() > 1 )
{ladder.add(END);
	Erase_START();
Erase_END();
Erase_H();
}
*/
		return ladder; // replace this line later with real return
	   
	}
	
	

	private static void Erase_START()
	{START = "";}
	private static void Erase_END() {END = "";}
	private static void Erase_H() { ladder_h.clear();}
	

    public static ArrayList<String> getWordLadderBFS(String start, String end) {
		// TODO some code
		Tree tree = new Tree(getDiffIndex(start, end), start, end);	//Generates tree
		ArrayList<String> ladder = new ArrayList<String>();	//Creates ladder
		Queue<String> frontier = new LinkedList<String>();	//Queue for frontier groups
		Set<String> visited = new HashSet<String>();	//Keeps track of all visited groups
		ArrayList<String> children = new ArrayList<String>();	//List of children for current group
		ArrayList<String> words = new ArrayList<String>();	//List of words for current group	
		int words_size= 0;	//Amount of words in current group
		int children_size = 0;	//Amount of children in current group
		String index = "";	//Current group index string removed from queue
		int low_diff = start.length();	//lowest difference from end word
		int curr_diff;	//difference of current word and end word
		String word_link;	//word in current group with lowest difference from end word, is only 1 char different
							//from last word in ladder, and is already in ladder
		int l_last;	//index of last element in ladder
		int l_diff;	//Difference of current word with last word in ladder
	    
		ladder.add(start);	//Adds start to ladder
		frontier.add(start);	//Adds start to frontier
		visited.add(start);	//Adds start to visited

        loop:
		//While there are still groups in frontier
		while(!frontier.isEmpty()){
			index = frontier.remove();
			children = tree.Get_Group(index).children;	
			words = tree.Get_Group(index).words;	
			children_size = children.size();
			words_size = words.size();
			l_last = ladder.size() - 1;

			//For each word in list of words for current group
			for (String word: words){
				if(word.equals(end)) break loop;	//if word is end word, stop
				curr_diff = getDiffIndex(word, end).length();
				l_diff = getDiffIndex(word, ladder.get(l_last)).length();
				//If word is valid to be added to ladder
				if (curr_diff < low_diff && l_diff == 1 && !ladder.contains(word)){
					low_diff = curr_diff;
					word_link = word;
				}
			}
			tree.Get_Group(index).Link_word.add(index, word_link);	//Add word to Link_word set with group index
			ladder.add(word_link);	//Add word to ladder
			//Add valid children to frontier queue
			for (String child : children){
				if (!visited.contains(child)){
					frontier.add(child);
					visited.add(child);
				}
			}

		}
		exit:
		ladder.add(end);

		return ladder;
		
	}
	


    
	
	public static void printLadder(ArrayList<String> ladder) {
	// TODO
	// Other private static methods here
		int size = ladder.size();
		String start = ladder.get(0);
		String end = ladder.get(size - 1);

		if(size > 2){
			System.out.printf ("a %d-rung word ladder exists between %s and %s.\n", size-2, start, end); 
			System.out.println (ladder.get(0).toLowerCase());	//Start word
			for (int i = 0; i < ladder.size(); i++) {	//Ladder words
            	System.out.println(ladder.get(i).toLowerCase());
        	}
			System.out.println(ladder.get(1).toLowerCase());	//End word
		}else{
			System.out.printf("no word ladder can be found between %s and %s.\n", start, end);
		}
	}

	/* Do not modify makeDictionary */
	public static Set<String>  makeDictionary () {
		Set<String> words = new HashSet<String>();
		Scanner infile = null;
		try {
			infile = new Scanner (new File("five_letter_words"));
		} catch (FileNotFoundException e) {
			System.out.println("Dictionary File not Found!");
			e.printStackTrace();
			System.exit(1);
		}
		while (infile.hasNext()) {
			words.add(infile.next().toUpperCase());
		}
		return words;
	}
}

